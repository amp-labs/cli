# See Makefile for the commands that generate Go types from this file.
# This file is referenced by api.yaml.

components:
  schemas:
    Manifest:
      type: object
      description: This is the schema of the manifest file that is used to define the integrations of the project.
      required:
        - specVersion
        - integrations
      properties:
        specVersion:
          type: string
          description: The version of the manifest spec that this file conforms to.
        integrations:
          type: array
          items:
            $ref: '#/components/schemas/Integration'

    Integration:
      type: object
      required:
        - name
        - provider
      properties:
        name:
          type: string
        displayName:
          type: string
        provider:
          type: string
        read:
          $ref: '#/components/schemas/IntegrationRead'
        write:
          $ref: '#/components/schemas/IntegrationWrite'
        proxy:
          $ref: '#/components/schemas/IntegrationProxy'

    IntegrationProxy:
      type: object
      properties:
        enabled:
          type: boolean

    IntegrationRead:
      type: object
      properties:
        standardObjects:
          type: array
          items:
            $ref: '#/components/schemas/IntegrationObject'

    IntegrationWrite:
      type: object
      properties:
        objects:
          type: array
          items:
            $ref: '#/components/schemas/IntegrationWriteObject'

    # This is currently only used for read actions.
    # Once we figure out whether to share the same type for both read and write, or use
    # different types, we can rename this to IntegrationReadObject if appropriate.
    IntegrationObject:
      type: object
      required:
        - objectName
        - destination
        - schedule
      properties:
        objectName:
          type: string
        destination:
          type: string
        schedule:
          type: string
        requiredFields:
          type: array
          items:
            $ref: '#/components/schemas/IntegrationField'
        optionalFields:
          type: array
          items:
            $ref: '#/components/schemas/IntegrationField'
        optionalFieldsAuto:
          $ref: '#/components/schemas/OptionalFieldsAutoOption'

    # We might end up using the same IntegrationObject type for both read and write,
    # but for now we're introducing a new type to keep them separate, and not renaming the
    # existing IntegrationObject.
    IntegrationWriteObject:
      type: object
      required:
        - objectName
      properties:
        objectName:
          type: string

    HydratedIntegration:
      type: object
      required:
        - name
        - provider
      properties:
        name:
          type: string
        displayName:
          type: string
        provider:
          type: string
        read:
          $ref: '#/components/schemas/HydratedIntegrationRead'
        write:
          $ref: '#/components/schemas/HydratedIntegrationWrite'
        proxy:
          $ref: '#/components/schemas/HydratedIntegrationProxy'

    HydratedIntegrationProxy:
      type: object
      properties:
        enabled:
          type: boolean

    HydratedIntegrationRead:
      type: object
      properties:
        standardObjects:
          type: array
          items:
            $ref: '#/components/schemas/HydratedIntegrationObject'

    HydratedIntegrationWrite:
      type: object
      properties:
        objects:
          type: array
          items:
            $ref: '#/components/schemas/HydratedIntegrationWriteObject'

    # This is currently only used for read actions.
    # Once we figure out whether to share the same type for both read and write, or use
    # different types, we can rename this to HydratedIntegrationReadObject if appropriate.
    HydratedIntegrationObject:
      type: object
      required:
        - objectName
        - displayName
        - destination
        - schedule
      properties:
        objectName:
          type: string
        displayName:
          type: string
        destination:
          type: string
        schedule:
          type: string
        requiredFields:
          type: array
          items:
            $ref: '#/components/schemas/HydratedIntegrationField'
        optionalFields:
          type: array
          items:
            $ref: '#/components/schemas/HydratedIntegrationField'
        optionalFieldsAuto:
          $ref: '#/components/schemas/OptionalFieldsAutoOption'
        allFields:
          description: This is a list of all fields on the object for a particular SaaS instance. This is used to populate the UI during configuration.
          type: array
          items:
            $ref: '#/components/schemas/HydratedIntegrationField'

    # We might end up using the same HydratedIntegrationObject type for both read and write,
    # but for now we're introducing a new type to keep them separate, and not renaming the
    # existing IntegrationObject.
    HydratedIntegrationWriteObject:
      type: object
      required:
        - objectName
        - displayName
      properties:
        objectName:
          type: string
        displayName:
          type: string

    OptionalFieldsAutoOption:
      type: string
      enum: [all]

    IntegrationField:
      oneOf:
        - $ref: '#/components/schemas/IntegrationFieldExistent'
        - $ref: '#/components/schemas/IntegrationFieldMapping'

    IntegrationFieldExistent:
      type: object
      required:
        - fieldName
      properties:
        fieldName:
          type: string

    IntegrationFieldMapping:
      type: object
      required:
        - mapToName
      properties:
        mapToName:
          type: string
        mapToDisplayName:
          type: string
        default:
          type: string
        prompt:
          type: string

    HydratedIntegrationField:
      oneOf:
        - $ref: '#/components/schemas/HydratedIntegrationFieldExistent'
        - $ref: '#/components/schemas/IntegrationFieldMapping'

    HydratedIntegrationFieldExistent:
      type: object
      required:
        - fieldName
        - displayName
      properties:
        fieldName:
          type: string
        displayName:
          type: string
